---
title: "2016 Election Analysis"
author: "Katie Chong"
date: "Due December 12, 2018, midnight"
output:
  html_document: default
  pdf_document: default
header-includes: \usepackage{animate}
editor_options:
  chunk_output_type: inline
always_allow_html: yes
---


# Instructions and Expectations

- You are allowed and encouraged to work with one partner on this project.  Include your names, perm numbers, and whether you are taking the class for 131 or 231 credit.

- You are welcome and encouraged to write up your report as a research paper (e.g. abstract, introduction, methods, results, conclusion) as long as you address each of the questions below.  Alternatively, you can format the assignment like a long homework by addressing each question in parts.

- There should be no raw R _output_ in the paper body!  All of your results should be formatted in a professional and visually appealing manner. That means, eather as a polished visualization or for tabular data, a nicely formatted table (see the documentation for [kable and kableExtra packages](https://haozhu233.github.io/kableExtra/awesome_table_in_pdf.pdf). If you feel you must include extensive raw R output, this should be included in an appendix, not the main report.  

- All R code should be available from your Rmarkdown file, but does not need to be shown in the body of the report!  Use the chunk option `echo=FALSE` to exclude code from appearing in your writeup.  In addition to your Rmarkdown, you should turn in the writuep as either a pdf document or an html file (both are acceptable).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = F, warning = F)

indent1 = '    '
indent2 = paste(rep(indent1, 2), collapse='')
indent3 = paste(rep(indent1, 3), collapse='')

doeval = TRUE
doecho = FALSE
devtools::session_info('rmarkdown')

library(knitr)
library(tidyverse)
library(kableExtra)
library(ggmap)
library(maps)
library(Rtsne)
library(NbClust)
library(tree)
library(maptree)
library(class)
library(glmnet)
library(ROCR)
library(reshape2)
library(randomForest)
```

Predicting voter behavior is complicated for many reasons despite the tremendous effort in collecting, analyzing, and understanding many available datasets. 
For our final project, we will analyze the 2016 presidential election dataset.

# Background

The presidential election in 2012 did not come as a surprise. Some correctly predicted the outcome of the election correctly including [Nate Silver](https://en.wikipedia.org/wiki/Nate_Silver), 
and [many speculated his approach](https://www.theguardian.com/science/grrlscientist/2012/nov/08/nate-sliver-predict-us-election).

Despite the success in 2012, the 2016 presidential election came as a 
[big surprise](https://fivethirtyeight.com/features/the-polls-missed-trump-we-asked-pollsters-why/) 
to many, and it was a clear example that even the current state-of-the-art technology can surprise us.

Answer the following questions in one paragraph for each.

**1. What makes voter behavior prediction (and thus election forecasting) a hard problem?**

The data that we have can only be from the poll before the election actually happens. A lot of times, voters' opinions will change as the election gets closer. This could be due to a particularly successful campaign ad or a sudden scandal of a candidate being exposed days before election. These random variables are difficult to measure, therefore, up until the election day, the polls generated are never 100 precent accurate. Also, sampling errors could orrcur when researchers accidentally poll more supporters of a candidate than are represented in the general population. And the voters might not answer truthfully. For example, if someone feels like he/she might get attacked by others around them if they reveal their true political opinion, then they might not speak their mind until the day of the election. On top of that, not everyone who answered the suyvey will turn out to vote.  

**2. What was unique to Nate Silver's approach in 2012 that allowed him to achieve good predictions?**

Instead of looking at the maximum probability, Nate Silver looked at the full range of probabilities. For each date, he proposed a prior belief of how much a candidate would get the new day. The next day he would get the new  data containing the actual probability of the support, and then updaet his model after observing the actual data.  

**3. What went wrong in 2016? What do you think should be done to make future predictions better?**

The biggest issues with 2016 election prediction were: a large change in voters' preferences during the final days before the election, overrepresentation of college graduates did not get adjusted and many of the Trump supporters did not speak their mind during the poll until the day of election. One of the ways to improve predicting results is to ask the voters about their past voting behavior. We can combine voter's self prediction and their past history to determine whether or not they will actually vote in the end.  

# Data

```{r data, message=FALSE, warning = FALSE}

## read data and convert candidate from string to factor
election.raw <- read_delim("data/election/election.csv", delim = ",") %>% mutate(candidate=as.factor(candidate))

census_meta <- read_delim("data/census/metadata.csv", delim = ";", col_names = FALSE) 
census <- read_delim("data/census/census.csv", delim = ",") 
```


## Election data

The meaning of each column in `election.raw` is clear except `fips`. The accronym is short for [Federal Information Processing Standard](https://en.wikipedia.org/wiki/FIPS_county_code).

In our dataset, `fips` values denote the area (US, state, or county) that each row of data represent. For example, `fips` value of 6037 denotes Los Angeles County.

```{r}
kable(election.raw %>% filter(county == "Los Angeles County"))  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)
```

Some rows in `election.raw` are summary rows and these rows have `county` value of `NA`. There are two kinds of summary rows:

* Federal-level summary rows have `fips` value of `US`.
* State-level summary rows have names of each states as `fips` value.

**4. Report the dimension of `election.raw` after removing rows with `fips=2000`. Provide a reason for excluding them. Please make sure to use the same name `election.raw` before and after removing those observations. **

```{r}
# removing rows with fips=2000
election.raw %>% filter(fips != 2000)
```
The dimension for election.row is now 18,345 x 5. We filtered out fips = 2000 because numerical values of fips represent county-level data. And we have missing values in the county column for fips = 2000. 
    
## Census data

Following is the first few rows of the `census` data:

```{r}
kable(census %>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")
```

### Census data: column metadata

Column information is given in `metadata`.

```{r, dependson=data, echo=FALSE, eval=FALSE}
kable(census_meta)
```

## Data wrangling
**5. Remove summary rows from `election.raw` data: i.e.,**

* Federal-level summary into a `election_federal`.
    
* State-level summary into a `election_state`.
    
* Only county-level data is to be in `election`.

```{r}
election_federal <- election.raw %>% filter(fips == "US")
election_state <- election.raw %>% filter(fips == state & fips != "US")
election <- election.raw %>% filter(!is.na(county))
```

**6. How many named presidential candidates were there in the 2016 election? Draw a bar chart of all votes received by each candidate.  You can split this into multiple plots or may prefer to plot the results on a log scale.  Either way, the results should be clear and legible!**

```{r, results='hide'}
# list of candidates 
kable(election_federal$candidate %>% head, "html", caption = "List of Candidates")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")
# count the number of candidates
# length(unique(election_federal$candidate))

election_federal %>% 
  filter(candidate !=  " None of these candidates") %>% 
  ggplot(aes(candidate, votes)) + 
  scale_y_log10() +
  geom_bar(stat = "identity") +
  ggtitle("Votes received by each candidate on a log scale") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.title = element_text(hjust = 0.5))  
```

There are 31 named presidential candidates in the 2016 election

**7. Create variables `county_winner` and `state_winner` by taking the candidate with the highest proportion of votes. **
  Hint: to create `county_winner`, start with `election`, group by `fips`, compute `total` votes, and `pct = votes/total`. 
  Then choose the highest row using `top_n` (variable `state_winner` is similar).
  
```{r}
state_winner <- election_state %>% group_by(fips, add = TRUE) %>% mutate(total = sum(votes)) %>% mutate(pct = votes/total) %>% top_n(1, pct)
county_winner <- election %>% group_by(fips, add = TRUE) %>% mutate(total = sum(votes)) %>% mutate(pct = votes/total) %>% top_n(1, pct)
```

# Visualization

Visualization is crucial for gaining insight and intuition during data mining. We will map our data onto maps.

The R package `ggplot2` can be used to draw maps. Consider the following code.

```{r}
states <- map_data("state")

ggplot(data = states) + 
  geom_polygon(aes(x = long, y = lat, fill = region, group = group), color = "white") + 
  coord_fixed(1.3) +
  guides(fill=FALSE)  # color legend is unnecessary and takes too long
```

The variable `states` contain information to draw white polygons, and fill-colors are determined by `region`.

**8. Draw county-level map by creating `counties = map_data("county")`. Color by county**

```{r}
county <- map_data("county")

ggplot(data = county) + 
  geom_polygon(aes(x = long, y = lat, fill = subregion, group = group), color = "white") + 
  coord_fixed(1.3) +
  guides(fill=FALSE)  # color legend is unnecessary and takes too long
```

**9. Now color the map by the winning candidate for each state.**  First, combine `states` variable and `state_winner` we created earlier using `left_join()`. Note that `left_join()` needs to match up values of states to join the tables.  A call to `left_join()` takes all the values from the first table and looks for matches in the second table. If it finds a match, it adds the data from the second table; if not, it adds missing values:
  
Here, we'll be combing the two datasets based on state name.  However, the state names are in different formats in the two tables: e.g. `AZ` vs. `arizona`. Before using `left_join()`, create a common column by creating a new column for `states` named `fips = state.abb[match(some_column, some_function(state.name))]`.  Replace `some_column` and `some_function` to complete creation of this new column. Then `left_join()`. Your figure will look similar to state_level [New York Times map](https://www.nytimes.com/elections/results/president).

```{r}
states <- states %>% mutate(fips = state.abb[match(region, tolower(state.name))])
states <- left_join(states, state_winner)

# color the map by the winning candidate for each state
ggplot(data = states) + 
  geom_polygon(aes(x = long, y = lat, fill = candidate, group = group), color = "white") + 
  coord_fixed(1.3)
```

**10. The variable `county` does not have `fips` column. So we will create one by pooling information from `maps::county.fips`.**
  Split the `polyname` column to `region` and `subregion`. Use `left_join()` combine `county.fips` into `county`. 
  Also, `left_join()` previously created variable `county_winner`. 
  Your figure will look similar to county-level [New York Times map](https://www.nytimes.com/elections/results/president).

```{r}
county.fips <- maps::county.fips 
county.fips <- county.fips %>% separate(polyname, c("region", "subregion"), sep = ",")

county <- left_join(county, county.fips)
county_winner$fips <- as.numeric(county_winner$fips)
county <- left_join(county, county_winner)

# color the map by the winning candidate for each county
ggplot(data = county) + 
  geom_polygon(aes(x = long, y = lat, fill = candidate, group = group), color = "white") + 
  coord_fixed(1.3)
```
  
**11. Create a visualization of your choice using `census` data.** Many exit polls noted that
    [demographics played a big role in the election](https://fivethirtyeight.com/features/demographics-not-hacking-explain-the-election-results/).
    Use [this Washington Post article](https://www.washingtonpost.com/graphics/politics/2016-election/exit-polls/)
    and [this R graph gallery](https://www.r-graph-gallery.com/) for ideas and inspiration.

```{r}
census.explore <- census %>% 
  filter(complete.cases(census[setdiff(names(census), 'CensusTract')])) %>% 
  mutate(Hispanic.num = Hispanic/100 * TotalPop,
             White.num = White/100 * TotalPop, 
           Black.num = Black/100 * TotalPop, 
           Native.num = Native/100 * TotalPop, 
           Asian.num = Asian/100 * TotalPop, 
           Pacific.num = Pacific/100 *TotalPop) %>% 
  select(CensusTract:Women, Hispanic.num:Pacific.num) %>%
  group_by(State) %>%
  summarize_at(vars(TotalPop:Pacific.num), funs(sum(.))) %>% 
  gather(key = 'race_population', value = 'population', Hispanic.num:Pacific.num) %>% 
  separate(race_population, c("race", "num")) %>% 
  select(-num)

ggplot(census.explore, aes(State, population, fill = race)) + 
  geom_bar(position = "identity", stat = "identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Population in each state by race")
```

**12. The `census` data contains high resolution information (more fine-grained than county-level). In this problem, we aggregate the information into county-level data by computing `TotalPop`-weighted average of each attributes for each county. Create the following variables:**
    
* _Clean census data `census.del`_: 
      start with `census`, filter out any rows with missing values, 
      convert {`Men`, `Employed`, `Citizen`} attributes to percentages (meta data seems to be inaccurate), 
      compute `Minority` attribute by combining {Hispanic, Black, Native, Asian, Pacific}, remove these variables after creating `Minority`, remove {`Walk`, `PublicWork`, `Construction`}.  
      _Many columns seem to be related, and, if a set that adds up to 100%, one column will be deleted._  
      
```{r}
census.del <- census %>% 
  filter(complete.cases(census[setdiff(names(census), 'CensusTract')])) %>% 
  mutate(Men = Men / TotalPop * 100, 
         Employed = Employed / TotalPop * 100, 
         Citizen = Citizen / TotalPop * 100) %>% 
  mutate(Minority = Hispanic + Black + Native + Asian + Pacific) %>% 
  select(-c(Women, Hispanic, Black, Native, Asian, Pacific, Walk, PublicWork, Construction))
```

* _Sub-county census data, `census.subct`_: 
      start with `census.del` from above, `group_by()` two attributes {`State`, `County`}, 
      use `add_tally()` to compute `CountyTotal`. Also, compute the weight by `TotalPop/CountyTotal`.
    
```{r}
census.subct <- census.del %>% 
  group_by(State, County, add = TRUE) %>% 
  add_tally(TotalPop) %>% 
  mutate(CountyTotal = n) %>%
  select(-n) %>% 
  mutate(weight = TotalPop / CountyTotal)
```

* _County census data, `census.ct`_: 
      start with `census.subct`, use `summarize_at()` to compute weighted sum
    
```{r}
census.ct <- census.subct %>% 
  summarize_at(vars(Men:Minority), funs(sum(. * weight)))
```

* _Print few rows of `census.ct`_: 
  
```{r}
kable(census.ct[c(100:105, 1000:1005), ] %>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")
```

# Dimensionality reduction

**13. Run PCA for both county & sub-county level data.** Save the first two principle components PC1 and PC2 into a two-column data frame, call it `ct.pc` and `subct.pc`, respectively. Discuss whether you chose to center and scale the features before running PCA and the reasons for your choice.  What are the three features with the largest absolute values of the first principal component? Which features have opposite signs and what does that mean about the correaltion between these features?

```{r}
# County level 
pr.out.ct <- prcomp(census.ct[, -c(1:2)], scale = TRUE, center = TRUE)
ct.pc <- pr.out.ct$x[, 1:2]
# Highest absolute loadings for PC1
pc1.vector.ct <- abs(pr.out.ct$rotation[, 1])
pc1.vector.ct <- sort(pc1.vector.ct, decreasing = TRUE) 
kable(head(pc1.vector.ct)%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")
# Look for negative correlation in PC1
kable(pr.out.ct$rotation[, 1], caption = "Negative correlations in PC1, county level"%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% scroll_box(width = "100%")

# Subcounty level 
pr.out.subct <- prcomp(census.subct[, -c(1:3)], scale = TRUE, center = TRUE)
subct.pc <- pr.out.subct$x[, 1:2]
# Highest absolute loadings for PC1
pc1.vector.subct <- abs(pr.out.subct$rotation[, 1])
pc1.vector.subct <- sort(pc1.vector.subct, decreasing = TRUE) 
kable(head(pc1.vector.subct)%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")
# Look for negative correlation in PC1
kable(pr.out.subct$rotation[, 1], caption = "Negative correlations in PC1, subcounty level"%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% scroll_box(width = "100%")
```

I choose to center and scale the features before I run PCA. In general, it is a good idea to scale the variables. Otherwise the magnitude to certain variables might dominates the associations between the variables. In our data, the variables are not recorded in the same scale, some of them are in percentage and some of them are not. 

The three features with the largest absolute values of the first principal component for county level data are: IncomePerCap, ChildPoverty and Poverty. The three features with the largest absolute values of the first principal component for sub-county level data are: IncomePerCap, Professional and Poverty.

Negative loadings means some negative correlations among variables. Features have opposite signs in PC1 of county level data are Poverty, ChildPoverty, Service, Office, Production, Drive, Carpool, OtherTransp, MeanCommute, UNemployment and Minority. Features have opposite signs in PC1 of sub-county level data are just the oppsite of county level data. This just means that variables like Poverty, ChildPoverty are negatively correlated to variables like Employed, Professional and Income. Another interesting negative correlation worth pointing out is Minority. Larger minority group corresponds with less income / less employed etc. in the area.  

**14. Determine the number of minimum number of PCs needed to capture 90% of the variance for both the county and sub-county analyses.** Plot proportion of variance explained (PVE) and cumulative PVE for both county and sub-county analyses.

```{r}
# County level 
pr.var.ct <- pr.out.ct$sdev ^ 2
pve.ct <- pr.var.ct/sum(pr.var.ct) 
cumulative_pve.ct <- cumsum(pve.ct)

# Number of minimum number of PCs needed to capture 90% of the variance
# min(which(cumulative_pve.ct >= 0.90))

## This will put the next two plots side by side 
par(mfrow=c(1, 2))

## Plot proportion of variance explained
plot(pve.ct, type="l", lwd=3, main = "PVE for County")
plot(cumulative_pve.ct, type="l", lwd=3, main = "Cumulative PVE for County")
```

```{r}
#Sub-county level
pr.var.subct <- pr.out.subct$sdev ^ 2
pve.subct <- pr.var.subct/sum(pr.var.subct) 
cumulative_pve.subct <- cumsum(pve.subct)

## This will put the next two plots side by side 
par(mfrow=c(1, 2))

# Number of minimum number of PCs needed to capture 90% of the variance
# min(which(cumulative_pve.subct >= 0.90))

## Plot proportion of variance explained
plot(pve.subct, type="l", lwd=3, main = "PVE for Sub-County")
plot(cumulative_pve.subct, type="l", lwd=3, main = "Cumulative PVE for Sub-County")
```

Minimum number of PCs needed to capture 90% of the variance for the county is 13 and for the sub-county is 17. 

# Clustering

**15. With `census.ct`, perform hierarchical clustering with complete linkage.**  Cut the tree to partition the observations into 10 clusters. Re-run the hierarchical clustering algorithm using the first 2 principal components from `ct.pc` as inputs instead of the originald features.  Compare and contrast the results. For both approaches investigate the cluster that contains San Mateo County. Which approach seemed to put San Mateo County in a more appropriate clusters? Comment on what you observe and discuss possible explanations for these observations.

```{r}
set.seed(1)

# hierarchical clustering for census.ct
census.ct.scaled <- as.data.frame(scale(census.ct[, -c(1:2)]))
dis.census.ct <- dist(census.ct.scaled, method="euclidean")
census.ct.hclust <- hclust(dis.census.ct, method = "complete")  
census.ct.hclust <- cutree(census.ct.hclust, k = 10)

# hierarchical clustering for ct.pc
ct.pc.scaled <- as.data.frame(scale(ct.pc))
dis.ct.pc <- dist(ct.pc.scaled, method="euclidean")
ct.pc.hclust <- hclust(dis.ct.pc, method = "complete")  
ct.pc.hclust <- cutree(ct.pc.hclust, k = 10)
```

```{r}
kable(census.ct %>% filter(County == "San Mateo"), caption = "San Mateo County"%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% scroll_box(width = "100%")

# Samples within the cluster containing "San Mateo"
# census.ct.hclust[which(census.ct$County == "San Mateo")]
samples.census.ct <- census.ct[which(census.ct.hclust == 7), ]
kable(summary(samples.census.ct), caption = "Sample summary for cluster 7"%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")

# ct.pc.hclust[which(census.ct$County == "San Mateo")]
samples.ct.cp <- census.ct[which(ct.pc.hclust == 4), ]
kable(summary(samples.ct.cp), caption = "Sample summary for cluster 4" %>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) %>% scroll_box(width = "100%")
```

Hierarchical clustering using census.ct seems like a better approach. From PCA analysis, we already know that the three features that play important role for county level data are: IncomePerCap, ChildPoverty and Poverty. Using census.ct data, San Mateo belongs in cluster 7. Using ct.pc data, San Mateo belongs to cluster 4. We then compared the mean of IncomePerCap, ChildPoverty and Poverty within each cluster with the actual IncomePerCap, ChildPoverty and Poverty rate of San Mateo. The samples in cluster 7 using census.ct.data has closer means to San Mateo than the samples in cluster 4 using ct.pc data. The same for other variables, samples from custer 7 using census.ct seem to have a closer mean to the actual observation. So cluster 7 using census.ct might be a better fit for San Mateo. This could be due to important cluster separation might sometimes take place in dimensions with weak variance, therefore dimension reduction might not always be better before clustering. 

# Classification

In order to train classification models, we need to combine `county_winner` and `census.ct` data.
This seemingly straightforward task is harder than it sounds. 
Following code makes necessary changes to merge them into `election.cl` for classification.

```{r}
tmpwinner <- county_winner %>% ungroup %>%
  mutate(state = state.name[match(state, state.abb)]) %>%               ## state abbreviations
  mutate_at(vars(state, county), tolower) %>%                           ## to all lowercase
  mutate(county = gsub(" county| columbia| city| parish", "", county))  ## remove suffixes
tmpcensus <- census.ct %>% ungroup %>% 
  mutate_at(vars(State, County), tolower)

election.cl <- tmpwinner %>%
  left_join(tmpcensus, by = c("state"="State", "county"="County")) %>% 
  na.omit

## save meta information
election.meta <- election.cl %>% select(c(county, fips, state, votes, pct, total))

## save predictors and class labels
election.cl = election.cl %>% select(-c(county, fips, state, votes, pct, total))
```

Using the following code, partition data into 80% training and 20% testing:
```{r, eval=TRUE}
set.seed(10) 
n <- nrow(election.cl)
in.trn <- sample.int(n, 0.8*n) 
trn.cl <- election.cl[ in.trn,]
tst.cl <- election.cl[-in.trn,]
```

Using the following code, define 10 cross-validation folds:
```{r, eval=TRUE}
set.seed(20) 
nfold <- 10
folds <- sample(cut(1:nrow(trn.cl), breaks=nfold, labels=FALSE))
```

Using the following error rate function:
```{r}
calc_error_rate = function(predicted.value, true.value){
  return(mean(true.value!=predicted.value))
}
records = matrix(NA, nrow=5, ncol=2)
colnames(records) = c("train.error","test.error")
rownames(records) = c("tree","logistic","lasso", "random forest", "knn")
```

## Classification

**16. Decision tree: train a decision tree by `cv.tree()`.** Prune tree to minimize misclassification error. Be sure to use the `folds` from above for cross-validation. Visualize the trees before and after pruning. Save training and test errors to `records` variable. Intepret and discuss the results of the decision tree analysis. Use this plot to tell a story about voting behavior in the US (remember the [NYT infographic?](https://archive.nytimes.com/www.nytimes.com/imagepages/2008/04/16/us/20080416_OBAMA_GRAPHIC.html))

```{r}
# Fit model on training set
tree.election <- tree(candidate ~., data = trn.cl) 

# Plot the tree
plot(tree.election)
text(tree.election, pretty = 0, cex = .5, col = "red")
title("Classification Tree Before Pruning")

# Set random seed
set.seed(69) 

# K-Fold cross validation
cv <- cv.tree(tree.election, FUN = prune.misclass, folds)
# Print out cv
# cv

# Best size
best.cv <- cv$size[which(cv$dev == min(cv$dev))]
best.size.cv <- min(best.cv)

# Prune tree.election
tree.election.pruned <- prune.misclass (tree.election, best = best.size.cv)

# Plot the tree
plot(tree.election.pruned)
text(tree.election.pruned, pretty = 0, cex = .6, col = "red")
title("Classification Tree After Pruning")

# Predict on train set and calculate train error
pred.tree.train <- predict(tree.election.pruned, trn.cl, type="class") 
tree_train_err <- calc_error_rate(pred.tree.train, trn.cl$candidate)

# Predict on test set and calculate test error
pred.tree.test <- predict(tree.election.pruned, tst.cl, type="class")
tree_test_err <- calc_error_rate(pred.tree.test, tst.cl$candidate)

records[1, 1] <- tree_train_err
records[1, 2] <- tree_test_err

kable(records, caption = "Records", "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)
```
The decision tree model gave us a 0.074 error rate on training dataset and slightly higher error rate of 0.083 testing datset. Overall, it did a good job. From the classification tree plot after pruning, we can see that counties that rely on public transiportation more tend to vote for Hillary. This could be due to areas where people rely on public transit more are usually the urban areas. In addition, the mojority of white demographic majority areas voted for Trump. For regions that white population less than 48 percent, the areas where income are low will vote for Hillary. And areas where unemployment rates are high would vote for Hillary as well. This is similar to what we have known: Demoncratics usually do better among minority and among poverty areas. 

**17. Run a logistic regression to predict the winning candidate in each county.**  Save training and test errors to `records` variable.  What are the significant variables? Are the consistent with what you saw in decision tree analysis? Interpret the meaning of a couple of the significant coefficients in terms of a unit change in the variables.  

```{r}
glm.fit <- glm(candidate ~.,
             data = trn.cl, family=binomial)
# Summarize the logistic regression model
kable(glm.fit$coefficients, caption = "logistic coefficient"%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% scroll_box(width = "100%")
```


In above results, `White`, `Citizen`, `IncomePerCap`, `Professional`, `Service`, `Production`, `Drive`, `Carpool`, `Employed`, `PrivateWork` and  `Unemployment` are statistically highly significant at level 0.001. The logistic regression coefficients, if logit link function is used, give the change in the log odds of the outcome for a one unit increase in a predictor variable, while others being held constant. For example: 

* The variable `White` has a coefficient `r round(summary(glm.fit)$coef[3],digits=4)`. For every one unit increase in `White`, the log odds of voting for Hillary (versus voting for Trump) decreases by 0.2217, holding other variables fixed. This is consistent with what we established in decision tree model: White population likes to vote for Trump. 

* The variable `Unemployment` has a coefficient `r round(summary(glm.fit)$coef[25],digits=4)`. For a one unit increase in `Unemloyment`, the log odds of voting for Hillary (versus voting for Trump) increases by 0.1838, holding other variables fixed. This is also consistent with what we seen in decision tree model: Unemployed population likes to vote for Hilliary.

Some other variables like IncomePerCap are also consistant with the conclusions we got from decision tree: Hilliary are more popular than Trump in poverty area. However, in decision tree, we use Transit as an important feature for classification. But in our logistic model, while holding other variables fixed, transit does not have a statistically significant value. 

```{r}
# predict training and testing datasets
prob.training <- predict(glm.fit, newdata = trn.cl, type="response")
prob.training <- round(prob.training, digits=2)

prob.test <- predict(glm.fit, newdata = tst.cl, type="response")
prob.test <- round(prob.test, digits=2)
```

```{r}
# Save the predicted labels using 0.5 as a threshold
pred.logistic.training <- as.factor(ifelse(prob.training<=0.5, "Donald Trump", "Hillary Clinton"))
pred.logistic.test <- as.factor(ifelse(prob.test<=0.5, "Donald Trump", "Hillary Clinton"))

# training error 
logistic_training_error <- 
  calc_error_rate(pred.logistic.training, droplevels(trn.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))
# testing error 
logistic_testing_error <- 
  calc_error_rate(pred.logistic.test, droplevels(tst.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))

# pass in to records 
records[2, 1] <- logistic_training_error
records[2, 2] <- logistic_testing_error

kable(records, caption = "Records", "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)
```

**18.  You may notice that you get a warning `glm.fit: fitted probabilities numerically 0 or 1 occurred`.**  As we discussed in class, this is an indication that we have perfect separation (some linear combination of variables _perfectly_ predicts the winner).  This is usually a sign that we are overfitting. One way to control overfitting in logistic regression is through regularization.  Use the `cv.glmnet` function from the `glmnet` library to run K-fold cross validation and select the best regularization parameter for the logistic regression with LASSO penalty.  Reminder: set `alpha=1` to run LASSO regression, set `lambda = c(1, 5, 10, 50) * 1e-4` in `cv.glmnet()` function to set pre-defined candidate values for the tuning parameter $\lambda$. This is because the default candidate values of $\lambda$ in `cv.glmnet()` is relatively too large for our dataset thus we use pre-defined candidate values. What is the optimal value of $\lambda$ in cross validation? What are the non-zero coefficients in the LASSO regression for the optimal value of $\lambda$? How do they compare to the unpenalized logistic regression?  Save training and test errors to the `records` variable.

```{r}
set.seed(1)

cv.out.lasso <- cv.glmnet(trn.cl %>% 
                            select(-candidate) %>% 
                            as.matrix, trn.cl$candidate %>% 
                            droplevels(except = c("Donald Trump", "Hillary Clinton")), alpha = 1, lambda = c(1, 5, 10, 50) * 1e-4, nfolds = 10, family="binomial")
bestlam <- cv.out.lasso$lambda.min
# bestlam 

lasso.mod <- glmnet(trn.cl %>% 
                            select(-candidate) %>% 
                            as.matrix, trn.cl$candidate %>% 
                            droplevels(except = c("Donald Trump", "Hillary Clinton")), alpha = 1, lambda = bestlam, family="binomial")

# predict training and testing datasets
lasso.pred.training <- predict(lasso.mod, newx = trn.cl %>% select(-candidate) %>% as.matrix, type = "class") 
lasso.pred.testing <- predict(lasso.mod, newx = tst.cl %>% select(-candidate) %>% as.matrix, type = "class") 

# training error 
lasso_training_error <- 
  calc_error_rate(lasso.pred.training, droplevels(trn.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))
# testing error 
lasso_testing_error <- 
  calc_error_rate(lasso.pred.testing, droplevels(tst.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))

# pass in to records 
records[3, 1] <- lasso_training_error
records[3, 2] <- lasso_testing_error
kable(records, caption = "Records", "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE) 

lasso.coef <- predict(lasso.mod, type="coefficients")[1:26,]
kable(lasso.coef, caption = "lasso coefficient"%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% scroll_box(width = "100%")
```

The optimal value of $\lambda$ in cross validation is 5e-04. The non-zero coefficients in the LASSO regression are every variable except for SelfEmployed, ChildPoverty and Minority. The absolute value of most of the values in the lasso coeffient is half of those in logistic regression. 

**19.  Compute ROC curves for the decision tree, logistic regression and LASSO logistic regression using predictions on the test data.**  Display them on the same plot.  Based on your classification results, discuss the pros and cons of the various methods.  Are the different classifiers more appropriate for answering different kinds of questions about the election?

```{r}
# Find the testing probabilities
prob.tree.test <- predict(tree.election.pruned, tst.cl, type="vector")
prob.logistic.test <- predict(glm.fit, tst.cl, type="response")
prob.lasso.test <- predict(lasso.mod, newx = tst.cl %>% select(-candidate) %>% as.matrix, type = "response")

# First arument is the predicted probabilities, second is true labels
pred_tree <- prediction(prob.tree.test[, 13], droplevels(tst.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))
pred_logistic <- prediction(prob.logistic.test, droplevels(tst.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))
pred_lasso <- prediction(prob.lasso.test, droplevels(tst.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))

# Secondly, we calculate the True Positive Rate and False Positive Rate by `performance()`.
# We want TPR on the y axis and FPR on the x axis
perf_tree <- performance(pred_tree, measure="tpr", x.measure="fpr")
perf_logistic <- performance(pred_logistic, measure="tpr", x.measure="fpr")
perf_lasso <- performance(pred_lasso, measure="tpr", x.measure="fpr")

# Plot the ROC curve
plot(perf_tree, col=2, lwd=2, main="ROC curve")
abline(0,1)
par(new=TRUE)
plot(perf_logistic, col=6, lwd=2)
par(new=TRUE)
plot(perf_lasso, col=3, lwd=2)

# Calculate AUC
auc.tree <- performance(pred_tree, "auc")@y.values
auc.logistic <- performance(pred_logistic, "auc")@y.values
auc.lasso <- performance(pred_lasso, "auc")@y.values
# auc.tree
# auc.logistic
# auc.lasso
```

From the ROC curve, we get the lasso prediction AUC is 0.9657537, which is larger than the AUC of tree prediction and logistic prediction, which is 0.917 and 0.96 respectively. Usually, an AUC larger than 0.95 is generally a good classification. This tells us lasso and logistic are better classfication than decision tree in this case, and by using regularization for the logistic model with the lasso penatly, we decrease overfitting on the training dataset, therefore has better prediction results on the testing dataset. The decision tree method gives us a clear visualization about the tree splits based on important factors, but lasso model and logistic model provide better analysis of each variable's importance while holding other variables fixed. This answers the question of what are some of the most important factors affecting voters' choice while holding all other variables constant. 

# Taking it further

**20. This is an open question. Interpret and discuss any overall insights gained in this analysis and possible explanations.** Use any tools at your disposal to make your case: visualize errors on the map, discuss what does/doesn't seems reasonable based on your understanding of these methods, propose possible directions (collecting additional data, domain knowledge, etc).  In addition, propose and tackle _at least_ one more interesting question. Creative and thoughtful analyses will be rewarded! _This part will be worth up to a 20\% of your final project grade!_

## Visualize errors on the map

We combine 'county' and 'tmpcensus'into 'election_map' using 'left_join', and then use our previous decision tree model and logistic regression model to predict on 'election_map'. 'Election_map' has all the observations from 'county', and contain all the necessary information to draw a U.S map.
```{r}
county_map <- county %>% ungroup %>%
  mutate(state = state.name[match(state, state.abb)]) %>%               ## state abbreviations
  mutate_at(vars(state, county), tolower) %>%                           ## to all lowercase
  mutate(county = gsub(" county| columbia| city| parish", "", county))  ## remove suffixes
election_map <- county_map %>%
  left_join(tmpcensus, by = c("state"="State", "county"="County")) %>% 
  na.omit

# Decision tree model error 
pred.tree.map <- predict(tree.election.pruned, election_map, type="class")
error.map <- election_map %>% mutate(prediction = ifelse(election_map$candidate != pred.tree.map, "incorrect", "correct"))
ggplot(data = error.map) + 
  geom_polygon(aes(x = long, y = lat, fill = prediction, group = group), color = "white") + 
  coord_fixed(1.3) + 
  ggtitle("Predition outcome for decision tree")

# Logistic model error 
prob.logistic.map <- predict(glm.fit, election_map, type="response") 
pred.logistic.map <- as.factor(ifelse(prob.logistic.map<=0.5, "Donald Trump", "Hillary Clinton"))
error.map <- election_map %>% mutate(prediction = ifelse(droplevels(election_map$candidate, except = c("Donald Trump", "Hillary Clinton")) != pred.logistic.map, "incorrect", "correct"))
ggplot(data = error.map) + 
  geom_polygon(aes(x = long, y = lat, fill = prediction, group = group), color = "white") + 
  coord_fixed(1.3) + 
  ggtitle("Predition outcome for logistic regression")
```


As we can see from above, logistic model has less incorrect prediction than decision tree model. Also worth noticing that most of the prediction improvements are from the west side of the countries. 

### Questions and concerns

* One thing that seems odd to me is the Transit variable in decision tree classification. We later found out that Income/IncomePerCap, Unemplyment and White variables used by decision tree model are also significantly important in other classification methods. Transit, however, does not show a level a significance when we use logistic regression or lasso regression. One possible explanation for this could be although Transit as a single variable does not have meaningful impart on predicting voters' preference, it has strong correlation with other variables. Therefore, we can also further explore this relationship by looking at the interaction terms in regression model. This will allow us to test more hypothesis about the effect of Transit for different values of other variables and therefore reach more accurate prediction results. 

* In PCA, IncomePerCap, ChildPoverty and Poverty are the three most important factors in the first principal component. However, ChildPoverty and Minority have coefficients of 0 in our Lasso regression. This might look contradictary at first, but then again this could be due to the ChildPoverty is higly related to, say Poverty. And we have only looked at the variables separately while holding all others constant in the regression models. Also even though we suspect that minority has a significant impact on voters' behavior, this variable could also highly correlated with variables like White. Different values of White can mean different impact of Minority on the regression model. 

* ChildPoverty and Minority have negative relationships with voting for Hillary. Although not significant, this seem strange to me because we thought larger ChildPoverty rate or Minority rate means more support for Hillary. In general, we can interpret and explain the results of our models better if we have clearer understanding of the U.S politics and/or past voting history. Perhaps we can gether more information from the past election dataset, and then build more models to analyze different factors affecting different voting behavior.  

### Random forest 
```{r}
trn.cl$candidate <- droplevels(trn.cl$candidate, except = c("Donald Trump", "Hillary Clinton"))
rf.election <- randomForest(candidate ~ ., data=trn.cl, ntree=500, importance=TRUE)
# rf.election
plot(rf.election)

kable(importance(rf.election)%>% head, "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% scroll_box(width = "100%")
varImpPlot(rf.election, sort=T, main="Variable Importance for Predicting Election", n.var=5)

pred.rf.train <- predict (rf.election, newdata = trn.cl)
pred.rf.test <- predict (rf.election, newdata = tst.cl)

# training error 
rf_training_error <- 
  calc_error_rate(pred.rf.train, droplevels(trn.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))
# testing error 
rf_testing_error <- 
  calc_error_rate(pred.rf.test, droplevels(tst.cl$candidate, except = c("Donald Trump", "Hillary Clinton")))

# pass in to records 
records[4, 1] <- rf_training_error
records[4, 2] <- rf_testing_error

kable(records, caption = "Records", "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)
```
We see that top 5 most impartant factors are Transit, White, Minority Professional and Unemployment. This is pretty consistent with what we have for other classification models. We have greatly improve our classification model by reducing the error rate of training and testing to 0.001222 and 0.0439, respectively. 

### KNN

We also would like to try the K nearst neighbor method for classification.  
```{r}
# YTrain is the true labels for High on the training set, XTrain is the design matrix
YTrain = trn.cl$candidate
XTrain = trn.cl %>% select(-candidate)
# YTest is the true labels for High on the test set, Xtest is the design matrix
YTest = tst.cl$candidate
XTest = tst.cl %>% select(-candidate)

# LOOCV 
validation.error = NULL
allK = 1:50
set.seed(66)
# For each number in allK, use LOOCV to find a validation error  
for (i in allK){  # Loop through different number of neighbors
    pred.Yval = knn.cv(train=XTrain, cl=YTrain, k=i) # Predict on the left-out validation set
    validation.error = c(validation.error, mean(pred.Yval!=YTrain)) # Combine all validation errors
}
numneighbor = max(allK[validation.error == min(validation.error)])
# numneighbor

# knn on the train set
pred.YTtrain = knn(train=XTrain, test=XTrain, cl=YTrain, k=numneighbor)
conf.train = table(predicted=pred.YTtrain, true=YTrain)
knn.train.err <- 1 - sum(diag(conf.train)/sum(conf.train))

# knn on test set
pred.YTest = knn(train=XTrain, test=XTest, cl=YTrain, k=numneighbor)
conf.test = table(predicted=pred.YTest, true=YTest)
knn.test.err <- 1 - sum(diag(conf.test)/sum(conf.test))

records[5, 1] <- knn.train.err
records[5, 2] <- knn.test.err
kable(records, caption = "Records", "html")  %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)
```
Using LOOCV method, the best number of neighbors is 27. Training our election data on KNN, we get a training error rate of 0.13 and a testing error rate of 0.15. Obviously, this is not a very good classification model for our election dataset. 